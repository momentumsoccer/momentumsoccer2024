#include <HardwareSerial.h>
#include <LCD_I2C.h>
HardwareSerial mySerial(2); // define a Serial for UART2
#include <Wire.h>    //Include wire library 
#include <MPU6050_light.h>  //Include library for MPU communication
const int mySerialRX = 16; // na esp32 isso eh o rx2 e o tx2
const int mySerialTX = 17;
int longe;

LCD_I2C lcd(0x27, 16, 2); // Default address of most PCF8574 modules, change according

MPU6050 mpu(Wire);
int angulogiro;
int anguloyaw;

float Kp = 6;
float Kd = 1.25;
float Ki = 10;

float target = 0;
float error = 0;
float integral = 0;
float derivative = 0;
float last_error = 0;

float angle = 0;
int x;

int IR[18];
const int portas[17] = {15, 4, 5, 18, 19, 36, 39, 23, 13, 12, 14, 26, 25, 33, 32, 35, 34};
const int minimo[17] = {4500, 4100, 3900, 4300, 4050, 4000, 4330, 4220, 3900, 3500, 4300, 4000, 3500, 3900, 4300, 4000, 4300};
//
//int valor1;
//int valor2;
//int valor3;
//int valor4;
//int valor5;
//int valor6;
//int valor7;
//int valor8;

int bola;

const int MAX = 10000;

int16_t ax, ay, az, gy, gx, gz;

void setup() {
  for (int i = 0; i < 17; i++)
  {
    if (i == 9)
      pinMode(12, INPUT_PULLDOWN); //porta12 (sensor 9)
    else
      pinMode(portas[i], INPUT);
  }
  for (int i = 0; i < 17; i++)
  {
    for (int j = 0; j < MAX; j++) IR[i] = 0;
  }
  Serial.begin(9600);
  mySerial.begin(9600, SERIAL_8N1, mySerialRX, mySerialTX);
  mySerial.setTimeout(5);
  Wire.begin();
  mpu.begin();
  mpu.calcGyroOffsets();
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }
  Serial.println("INICIADO");
  lcd.begin(); // If you are using more I2C devices using the Wire library use lcd.begin(false)
  // this stop the library(LCD_I2C) from calling Wire.begin()
  lcd.backlight();


}

bool direita = 1;
bool esquerda = 1;
bool frente = 1;

void loop() {
  // put your main code here, to run repeatedly:
  int index = -1;
  mpu.update();

  angulogiro = mpu.getAngleZ();
  anguloyaw = mpu.getAngleZ();


  if (anguloyaw >= 360)
  {
    anguloyaw = anguloyaw % 360;
  }
  if (anguloyaw < 0 && anguloyaw >= -360);
  {
    anguloyaw = anguloyaw % 360;
  }

  error = target - anguloyaw;// proportional
  integral = integral + error; //integral
  derivative = error - last_error; //derivative
  last_error = error;


  angle = (error * Kp); // + (derivative* Kd);w

  lcd.setCursor(0, 1); // Or setting the cursor in the desired position.
  lcd.print(anguloyaw);

  lcd.setCursor(0, 0); // Or setting the cursor in the desired position.
  lcd.print(angle);



  if (angulogiro >= 360 )
  {
    angulogiro = angulogiro % 360;
  }
  if (angulogiro < 0 && angulogiro >= -360);
  {
    angulogiro = angulogiro % 360;
  }
  for (int i = 0, min_ = 10000; i < 17; i++)
  {
    for (int j = 0; j <= MAX; j++) IR[i] += digitalRead(portas[i]);
    IR[i] = map(IR[i], minimo[i], 10000, 0, 100);
    if (IR[i] < min_ && IR[i] >= 0)
    {
      min_ = IR[i];
      index = i;
    }
  }

  Serial.println(bola);

  if (IR[0] < 6 && IR[16] < 9)
  {
    bola = 1024; //true
    //while (!mySerial.available());
    if (mySerial.available())
    {
      x = mySerial.parseInt();
       Serial.println(x);
      if (x != 0)
      {
       
        Serial.println(x);
        if (x == 333)
        {
          //          if (direita == 1 || frente == 1) {
          Serial.println("esquerda");
          mySerial.println(333); //esquerda
          //            esquerda = 1;
          //            direita = 0;
          //            frente = 0;
          // }

        }
        else if (x == 666) {
          // if (esquerda == 1 || frente == 1) {
          Serial.println("direita");
          mySerial.println(666); //direita
          //            direita = 1;
          //            esquerda = 0;
          //            frente = 0;
          //          }
        }
        else if (x == 444)
        {
          //   if (direita == 1 || esquerda == 1) {
          Serial.println("frente"); 
          mySerial.println(444); //frente
          //            frente = 1;
          //            direita = 0;
          //            esquerda = 0;
          //          }
        }
        mySerial.flush();
      }
    }

  }
  else
  {
    bola = 1023; //false
  }
  switch (index)
  {
    case 0: //IR1
      //Serial.println(1002);
      mySerial.println(1002);
      break;
    case 1:
      //Serial.println(1003);
      mySerial.println(1003);
      break;
    case 2:
      //Serial.println(1004);
      mySerial.println(1004);
      break;
    case 3:
      //Serial.println(1005);
      mySerial.println(1005);
      break;
    case 4:
      //Serial.println(1006);
      mySerial.println(1006);
      break;
    case 5:
      //Serial.println(1007);
      mySerial.println(1007);
      break;
    case 6:
      //Serial.println(1008);
      mySerial.println(1008);
      break;
    case 7:
      //Serial.println(1009);
      mySerial.println(1009);
      break;
    case 8:
      //Serial.println(1010);
      mySerial.println(1010);
      break;
    case 9:
      //Serial.println(1011);
      mySerial.println(1011);
      break;
    case 10:
      //Serial.println(1012);
      mySerial.println(1012);
      break;
    case 11:
      //Serial.println(1013);
      mySerial.println(1013);
      break;
    case 12:
      //Serial.println(1014);
      mySerial.println(1014);
      break;
    case 13:
      //Serial.println(1015);
      mySerial.println(1015);
      break;
    case 14:
      //Serial.println(1016);
      mySerial.println(1016);
      break;
    case 15:
      //Serial.println(1017);
      mySerial.println(1017);
      break;
    case 16:
      //Serial.println(1018);
      mySerial.println(1018);
      break;
    default:
      Serial.println("Invalido");

  }
  for (int k = 0; k < 17; k++)
  {
    IR[k] = 0;
  }
  mpu.update();

  mySerial.println(bola);
  Serial.println (angulogiro);
  mySerial.println(angulogiro + 3000);
  //mySerial.println(angle + 6000);
  //Serial.println(angle);
  lcd.clear();

}





























